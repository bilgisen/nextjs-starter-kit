name: Build and Publish EPUB

on:
  workflow_dispatch:
    inputs:
      book_slug:
        description: 'Book slug (e.g., my-awesome-book)'
        required: true
        type: string
      timestamp:
        description: 'Timestamp for unique build identification'
        required: true
        type: string

env:
<<<<<<< HEAD
  # Application configuration
  NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'https://bookedit.netlify.app' }}
=======
  NEXT_PUBLIC_APP_URL: ${{ vars.NEXT_PUBLIC_APP_URL || 'https://bookedit.vercel.app' }}
  NEXT_EPUB_SECRET: ${{ secrets.NEXT_EPUB_SECRET || 'OYh7fJu98ObHM' }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN || github.token }}
>>>>>>> d9005243156b2425d7b8fa64e481d170453c12b5
  NODE_ENV: production
  
  # JWT configuration
  JWT_ISSUER: ${{ vars.JWT_ISSUER || vars.NEXT_PUBLIC_APP_URL || 'https://bookedit.netlify.app' }}
  JWT_AUDIENCE: ${{ vars.JWT_AUDIENCE || 'workflow' }}
  
  # Secrets - these should be set in GitHub repository secrets
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  WORKFLOW_USER_ID: ${{ secrets.WORKFLOW_USER_ID || 'github-action' }}

jobs:
  build-epub:
    name: Build EPUB
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm install --legacy-peer-deps

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            pandoc \
            texlive-xetex \
            texlive-fonts-recommended \
            texlive-latex-recommended \
            jq \
            wget \
            parallel

      - name: Generate JWT Token
        id: generate-token
        env:
          BOOK_SLUG: ${{ github.event.inputs.book_slug }}
          TIMESTAMP: ${{ github.event.inputs.timestamp }}
          WORKFLOW_ID: ${{ github.run_id }}
        run: |
          # Install required tools
          echo "Installing jq and jose-cli..."
          sudo apt-get update
          sudo apt-get install -y jq
          npm install -g @panva/jose-cli
          
          # Generate JWT token
          echo "Generating JWT token..."
          NOW=$(date +%s)
          EXPIRY=$((NOW + 3600)) # 1 hour from now
          
          JWT_PAYLOAD=$(jq -n \
            --arg sub "$WORKFLOW_USER_ID" \
            --arg iat "$NOW" \
            --arg exp "$EXPIRY" \
            --arg iss "$JWT_ISSUER" \
            --arg aud "$JWT_AUDIENCE" \
            --arg workflowId "$WORKFLOW_ID" \
            --arg bookSlug "$BOOK_SLUG" \
            '{
              sub: $sub,
              iat: ($iat | tonumber),
              exp: ($exp | tonumber),
              iss: $iss,
              aud: $aud,
              workflowId: $workflowId,
              bookSlug: $bookSlug
            }')
          
          # Sign the token with HS256
          JWT_TOKEN=$(jose jwt sign \
            --secret "$JWT_SECRET" \
            --alg HS256 \
            --iss "$JWT_ISSUER" \
            --aud "$JWT_AUDIENCE" \
            --sub "$WORKFLOW_USER_ID" \
            --exp "$EXPIRY" \
            -- "$JWT_PAYLOAD")
          
          echo "JWT_TOKEN=$JWT_TOKEN" >> $GITHUB_ENV
          echo "JWT_HEADER=Bearer $JWT_TOKEN" >> $GITHUB_ENV
          echo "Generated JWT token"
      
      - name: Fetch Book Payload
        id: fetch-payload
        env:
          # Inputs from workflow_dispatch
          BOOK_SLUG: ${{ github.event.inputs.book_slug }}
          TIMESTAMP: ${{ github.event.inputs.timestamp }}
          
          # Environment variables
          BASE_URL: ${{ env.NEXT_PUBLIC_APP_URL }}
          JWT_ISSUER: ${{ env.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ env.JWT_AUDIENCE }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          WORKFLOW_USER_ID: ${{ secrets.WORKFLOW_USER_ID || 'github-action' }}
        run: |
          echo "Fetching book payload for $BOOK_SLUG"
          mkdir -p ./book-content/chapters
          
          # Fetch the book payload using the internal API
          PAYLOAD_URL="$BASE_URL/api/books/$BOOK_SLUG/payload"
          echo "Fetching payload from: $PAYLOAD_URL"
          
          if ! curl -s -f -o ./book-content/payload.json \
                    -H "Accept: application/json" \
                    -H "Authorization: $JWT_HEADER" \
                    "$PAYLOAD_URL?t=$TIMESTAMP"; then
            echo "::error::Failed to download book payload"
            exit 1
          fi
          
          # Validate the payload
          if [ ! -s "./book-content/payload.json" ]; then
            echo "::error::Received empty payload"
            exit 1
          fi
          
          # Extract book info with better error handling
          set +e
          BOOK_TITLE=$(jq -r '.book.title // "Untitled Book"' ./book-content/payload.json 2>/dev/null)
          if [ $? -ne 0 ]; then
            echo "::error::Invalid payload format: failed to parse book title"
            jq . ./book-content/payload.json >&2
            exit 1
          fi
          
          BOOK_LANG=$(jq -r '.book.language // "en"' ./book-content/payload.json 2>/dev/null)
          COVER_URL=$(jq -r '.book.cover_url // empty' ./book-content/payload.json 2>/dev/null)
          STYLESHEET_URL=$(jq -r '.book.stylesheet_url // empty' ./book-content/payload.json 2>/dev/null)
          TOC_DEPTH=$(jq -r '.options.toc_depth // 2' ./book-content/payload.json 2>/dev/null)
          set -e
          
          # Download cover image if available
          if [ -n "$COVER_URL" ]; then
            echo "Downloading cover image from $COVER_URL"
            wget -O ./book-content/cover.jpg "$COVER_URL" || echo "Warning: Failed to download cover image"
          fi
          
          # Download stylesheet if available
          if [ -n "$STYLESHEET_URL" ]; then
            echo "Downloading stylesheet from $STYLESHEET_URL"
            mkdir -p ./book-content/styles
            wget -O ./book-content/styles/epub.css "$STYLESHEET_URL" || echo "Warning: Failed to download stylesheet"
          fi
          
          # Download chapters in parallel with better error handling
          echo "Downloading chapters..."
          if ! jq -r '.book.chapters[] | "\(.order) \(.url)"' ./book-content/payload.json 2>/dev/null > ./book-content/chapters-list.txt; then
            echo "::error::Failed to extract chapter list from payload"
            exit 1
          fi
          
          # Process chapters in batches to avoid rate limiting
          BATCH_SIZE=5
          TOTAL_CHAPTERS=$(wc -l < ./book-content/chapters-list.txt)
          echo "Found $TOTAL_CHAPTERS chapters to process"
          
          for ((i=0; i<TOTAL_CHAPTERS; i+=BATCH_SIZE)); do
            echo "Processing chapters $((i+1))-$((i+BATCH_SIZE)) of $TOTAL_CHAPTERS..."
            cat ./book-content/chapters-list.txt | \
              tail -n +$((i+1)) | head -n $BATCH_SIZE | \
              parallel --colsep ' ' '
                set -e
                ORDER={1}
                URL={2}
                echo "Downloading chapter $ORDER..."
                if ! curl -s -f -o "./book-content/chapters/chapter-${ORDER}.xhtml" \
                         -H "Accept: application/json" \
                         -H "X-GitHub-Event: workflow_dispatch" \
                         -H "X-Hub-Signature-256: $NEXT_EPUB_SECRET" \
                         "$URL"; then
                  echo "::warning::Failed to download chapter $ORDER"
                  false
                fi
              '
            # Small delay between batches
            sleep 2
          done
          
          # Download imprint if enabled
          if [ "$(jq -r '.options.include_imprint // false' ./book-content/payload.json)" = "true" ]; then
            IMPRINT_URL=$(jq -r '.book.imprint.url // empty' ./book-content/payload.json)
            if [ -n "$IMPRINT_URL" ]; then
              echo "Downloading imprint from $IMPRINT_URL"
              wget --header="Authorization: Bearer $AUTH_TOKEN" -O ./book-content/imprint.xhtml "$IMPRINT_URL" || \
                echo "Warning: Failed to download imprint"
            fi
          fi
          
          echo "All content downloaded successfully"

      - name: Generate EPUB with Pandoc
        run: |
          echo "Generating EPUB for $BOOK_SLUG"
          mkdir -p ./output
          
          # Get options from payload
          GENERATE_TOC=$(jq -r '.options.generate_toc // true' ./book-content/payload.json)
          INCLUDE_IMPRINT=$(jq -r '.options.include_imprint // true' ./book-content/payload.json)
          TOC_DEPTH=$(jq -r '.options.toc_depth // 2' ./book-content/payload.json)
          
          # Prepare the list of files to include in the EPUB
          FILES=()
          PANDOC_OPTS=()
          
          # Add TOC options if enabled
          if [ "$GENERATE_TOC" = "true" ]; then
            PANDOC_OPTS+=("--toc" "--toc-depth=$TOC_DEPTH")
            echo "Including table of contents with depth: $TOC_DEPTH"
          else
            echo "Table of contents generation is disabled"
          fi
          
          # Add cover if available and enabled
          COVER_ENABLED=$(jq -r '.options.cover // true' ./book-content/payload.json)
          if [ "$COVER_ENABLED" = "true" ] && [ -f "./book-content/cover.jpg" ]; then
            FILES+=("--epub-cover-image=./book-content/cover.jpg")
            echo "Including cover image"
          fi
          
          # Add stylesheet if available
          if [ -f "./book-content/styles/epub.css" ]; then
            FILES+=("--css=./book-content/styles/epub.css")
          fi
          
          # Add chapters in order
          for f in $(ls -v ./book-content/chapters/chapter-*.xhtml); do
            FILES+=("$f")
          done
          
          # Add imprint if enabled and available
          if [ "$INCLUDE_IMPRINT" = "true" ] && [ -f "./book-content/imprint.xhtml" ]; then
            FILES+=("./book-content/imprint.xhtml")
            echo "Including imprint page"
          elif [ "$INCLUDE_IMPRINT" = "true" ]; then
            echo "Warning: Imprint was enabled but not found"
          fi
          
          # Get metadata from payload
          TITLE=$(jq -r '.book.title // "Untitled Book"' ./book-content/payload.json)
          AUTHOR=$(jq -r '.book.author // "Unknown Author"' ./book-content/payload.json)
          LANGUAGE=$(jq -r '.book.language // "en"' ./book-content/payload.json)
          
          # Get book slug from environment variable
          BOOK_SLUG="${{ github.event.inputs.book_slug }}"
          
          # Generate EPUB using Pandoc
          echo "Running Pandoc with ${#FILES[@]} files"
          
          # Build the full command
          set -x  # Print commands for debugging
          pandoc \
            --from=html \
            --to=epub3 \
            --output=./output/book.epub \
            --epub-chapter-level=1 \
            --metadata="title:$TITLE" \
            --metadata="author:$AUTHOR" \
            --metadata="language:$LANGUAGE" \
            --metadata="identifier:$BOOK_SLUG" \
            "${PANDOC_OPTS[@]}" \
            "${FILES[@]}"
          
          # Verify EPUB was created
          if [ ! -f "./output/book.epub" ]; then
            echo "Error: Failed to generate EPUB"
            exit 1
          fi
          
          echo "EPUB generated successfully"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: epub-file
          path: ./output/*.epub
          retention-days: 1
